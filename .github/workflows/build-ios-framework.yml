#
# Unified Modern Workflow: Build DuckDB with httpfs for iOS
#
# Features:
# - Dynamic DuckDB version detection
# - Uses pre-built OpenSSL/cURL from yharby/openssl_for_ios_and_android
# - XCFramework output with device + simulator support
# - Statically linked extensions (icu, json, parquet, httpfs, fts, inet, vss, autocomplete)
#

name: Build iOS Framework

on:
  workflow_dispatch:
    inputs:
      duckdb_version:
        description: 'DuckDB version (leave empty for latest)'
        required: false
        default: ''
      openssl_release_tag:
        description: 'OpenSSL release tag from yharby/openssl_for_ios_and_android (leave empty for latest)'
        required: false
        default: ''
      create_release:
        description: 'Create a GitHub release'
        type: boolean
        default: true
  schedule:
    # Check for new DuckDB releases weekly (Sundays at midnight)
    - cron: '0 0 * * 0'

env:
  DUCKDB_REPO: duckdb/duckdb
  OPENSSL_REPO: yharby/openssl_for_ios_and_android

  # ========== EXTENSION CONFIGURATION ==========
  # Core extensions (built-in to DuckDB, use BUILD_EXTENSIONS)
  CORE_EXTENSIONS: "icu;json;parquet;httpfs;fts;inet;vss;autocomplete;ducklake;sqlite_scanner;postgres_scanner"

  # Community extensions (loaded via DUCKDB_EXTENSION_CONFIGS with SOURCE_DIR)
  # Format: "name|repo|branch" separated by spaces
  # These require git clone --recursive to get submodules
  COMMUNITY_EXTENSIONS: "h3|isaacbrodsky/h3-duckdb|main"
  # To add more: "h3|isaacbrodsky/h3-duckdb|main a5|Query-farm/a5|main"
  # Note: a5 requires Rust toolchain for cross-compilation
  # =============================================

  # Minimum iOS version
  IOS_MIN_VERSION: "12.0"

jobs:
  # ============================================================
  # Job 1: Check versions and prepare build
  # ============================================================
  prepare:
    name: Prepare Build
    runs-on: ubuntu-latest
    outputs:
      duckdb_version: ${{ steps.versions.outputs.duckdb }}
      should_build: ${{ steps.check.outputs.should_build }}
      release_tag: ${{ steps.versions.outputs.release_tag }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Detect DuckDB Version
        id: versions
        run: |
          if [ -n "${{ github.event.inputs.duckdb_version }}" ]; then
            DUCKDB_VERSION="${{ github.event.inputs.duckdb_version }}"
          else
            DUCKDB_VERSION=$(curl -s https://api.github.com/repos/${{ env.DUCKDB_REPO }}/releases/latest | \
              jq -r '.tag_name // empty' | sed 's/^v//')
            [ -z "$DUCKDB_VERSION" ] || [ "$DUCKDB_VERSION" = "null" ] && DUCKDB_VERSION="1.4.3"
          fi
          echo "duckdb=$DUCKDB_VERSION" >> $GITHUB_OUTPUT
          echo "release_tag=v${DUCKDB_VERSION}-ios" >> $GITHUB_OUTPUT
          echo "DuckDB version: $DUCKDB_VERSION"

      - name: Check if Release Exists
        id: check
        run: |
          RELEASE_TAG="v${{ steps.versions.outputs.duckdb }}-ios"

          if gh release view "$RELEASE_TAG" --repo ${{ github.repository }} &>/dev/null; then
            echo "Release $RELEASE_TAG already exists"
            echo "should_build=false" >> $GITHUB_OUTPUT
          else
            echo "Release $RELEASE_TAG does not exist, will build"
            echo "should_build=true" >> $GITHUB_OUTPUT
          fi
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  # ============================================================
  # Job 2: Build DuckDB for iOS
  # ============================================================
  build:
    name: Build iOS (${{ matrix.target }})
    needs: prepare
    if: needs.prepare.outputs.should_build == 'true'
    runs-on: macos-14
    strategy:
      fail-fast: false
      matrix:
        include:
          - target: ios-arm64
            platform: iphoneos
            arch: arm64
            sdk: iphoneos
            cmake_system: iOS
            sysroot_flag: ""
          - target: ios-simulator-arm64
            platform: iphonesimulator
            arch: arm64
            sdk: iphonesimulator
            cmake_system: iOS
            sysroot_flag: "-DCMAKE_OSX_SYSROOT=iphonesimulator"
          - target: ios-simulator-x86_64
            platform: iphonesimulator
            arch: x86_64
            sdk: iphonesimulator
            cmake_system: iOS
            sysroot_flag: "-DCMAKE_OSX_SYSROOT=iphonesimulator"

    steps:
      - name: Setup Xcode
        uses: maxim-lobanov/setup-xcode@v1
        with:
          xcode-version: latest-stable

      - name: Download OpenSSL and cURL
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          # Get iOS release tag from yharby/openssl_for_ios_and_android
          if [ -n "${{ github.event.inputs.openssl_release_tag }}" ]; then
            RELEASE_TAG="${{ github.event.inputs.openssl_release_tag }}"
          else
            # Use gh CLI to get the latest iOS release
            RELEASE_TAG=$(gh release list --repo ${{ env.OPENSSL_REPO }} --limit 20 | grep "^ios-" | head -1 | awk '{print $3}')
            [ -z "$RELEASE_TAG" ] && RELEASE_TAG="ios-openssl3.0.18-curl8.17.0"
          fi
          echo "Using OpenSSL release: $RELEASE_TAG"

          mkdir -p deps/{openssl,curl}/{lib,include}

          # Determine suffix based on platform
          if [ "${{ matrix.platform }}" = "iphoneos" ]; then
            SUFFIX="ios-arm64"
          else
            SUFFIX="ios-simulator"
          fi

          # Download all matching assets using gh CLI
          gh release download "$RELEASE_TAG" --repo ${{ env.OPENSSL_REPO }} \
            --pattern "*${SUFFIX}.zip" --dir deps/

          # Extract OpenSSL
          OPENSSL_ZIP=$(ls deps/openssl_*-${SUFFIX}.zip 2>/dev/null | head -1)
          if [ -n "$OPENSSL_ZIP" ]; then
            unzip -o "$OPENSSL_ZIP" -d deps/openssl_tmp
            cp deps/openssl_tmp/openssl/lib/*.a deps/openssl/lib/
            cp -r deps/openssl_tmp/openssl/include/* deps/openssl/include/
            rm -rf deps/openssl_tmp "$OPENSSL_ZIP"
          fi

          # Extract cURL
          CURL_ZIP=$(ls deps/curl_*-${SUFFIX}.zip 2>/dev/null | head -1)
          if [ -n "$CURL_ZIP" ]; then
            unzip -o "$CURL_ZIP" -d deps/curl_tmp
            cp deps/curl_tmp/curl/lib/*.a deps/curl/lib/
            cp -r deps/curl_tmp/curl/include/* deps/curl/include/
            rm -rf deps/curl_tmp "$CURL_ZIP"
          fi

          # Extract nghttp2
          NGHTTP2_ZIP=$(ls deps/nghttp2_*-${SUFFIX}.zip 2>/dev/null | head -1)
          if [ -n "$NGHTTP2_ZIP" ]; then
            unzip -o "$NGHTTP2_ZIP" -d deps/nghttp2_tmp
            cp deps/nghttp2_tmp/nghttp2/lib/*.a deps/curl/lib/  # Put nghttp2 with curl libs
            rm -rf deps/nghttp2_tmp "$NGHTTP2_ZIP"
          fi

          echo "=== OpenSSL libraries ==="
          ls -la deps/openssl/lib/
          echo "=== cURL libraries ==="
          ls -la deps/curl/lib/

      - name: Download DuckDB Source
        run: |
          DUCKDB_VERSION="${{ needs.prepare.outputs.duckdb_version }}"
          echo "Downloading DuckDB v${DUCKDB_VERSION}"

          # Use git clone to handle symlinks properly
          git clone --depth 1 --branch "v${DUCKDB_VERSION}" \
            "https://github.com/${{ env.DUCKDB_REPO }}.git" duckdb-src

      - name: Clone Community Extensions
        run: |
          # Parse COMMUNITY_EXTENSIONS and clone each one
          # Format: "name|repo|branch" separated by spaces
          EXTENSIONS="${{ env.COMMUNITY_EXTENSIONS }}"
          for ext in $EXTENSIONS; do
            EXT_NAME=$(echo "$ext" | cut -d'|' -f1)
            EXT_REPO=$(echo "$ext" | cut -d'|' -f2)
            EXT_BRANCH=$(echo "$ext" | cut -d'|' -f3)

            echo "=== Cloning community extension: $EXT_NAME from $EXT_REPO ($EXT_BRANCH) ==="
            git clone --recursive --branch "$EXT_BRANCH" "https://github.com/${EXT_REPO}.git" "${EXT_NAME}-ext"
            ls -la "${EXT_NAME}-ext/"
          done

      - name: Create Community Extension Config
        run: |
          # Generate extension config from COMMUNITY_EXTENSIONS
          echo "# Community extensions config (auto-generated)" > duckdb-src/extension_config_mobile.cmake

          EXTENSIONS="${{ env.COMMUNITY_EXTENSIONS }}"
          for ext in $EXTENSIONS; do
            EXT_NAME=$(echo "$ext" | cut -d'|' -f1)
            echo "duckdb_extension_load($EXT_NAME" >> duckdb-src/extension_config_mobile.cmake
            echo "    SOURCE_DIR \"\${GITHUB_WORKSPACE}/${EXT_NAME}-ext\"" >> duckdb-src/extension_config_mobile.cmake
            echo ")" >> duckdb-src/extension_config_mobile.cmake
          done

          echo "=== Extension config ==="
          cat duckdb-src/extension_config_mobile.cmake

      - name: Build DuckDB
        env:
          DUCKDB_PLATFORM: osx_arm64
        run: |
          cd duckdb-src
          mkdir -p build/${{ matrix.target }}
          cd build/${{ matrix.target }}

          OPENSSL_DIR="${GITHUB_WORKSPACE}/deps/openssl"
          CURL_DIR="${GITHUB_WORKSPACE}/deps/curl"

          # Build dynamic library for iOS
          cmake ../.. \
            -G Ninja \
            -DCMAKE_SYSTEM_NAME=${{ matrix.cmake_system }} \
            -DCMAKE_OSX_ARCHITECTURES=${{ matrix.arch }} \
            -DCMAKE_OSX_DEPLOYMENT_TARGET=${{ env.IOS_MIN_VERSION }} \
            ${{ matrix.sysroot_flag }} \
            -DCMAKE_BUILD_TYPE=Release \
            -DBUILD_SHARED_LIBS=ON \
            -DBUILD_SHELL=OFF \
            -DBUILD_UNITTESTS=OFF \
            -DEXTENSION_STATIC_BUILD=ON \
            -DBUILD_EXTENSIONS="${{ env.CORE_EXTENSIONS }}" \
            -DDUCKDB_EXTENSION_CONFIGS="${GITHUB_WORKSPACE}/duckdb-src/extension_config_mobile.cmake" \
            -DSKIP_EXTENSIONS="core_functions" \
            -DBUILD_LOADABLE_EXTENSIONS=OFF \
            -DENABLE_EXTENSION_AUTOLOADING=OFF \
            -DENABLE_EXTENSION_AUTOINSTALL=OFF \
            -DDUCKDB_EXPLICIT_PLATFORM=osx_${{ matrix.arch == 'arm64' && 'arm64' || 'amd64' }} \
            -DOPENSSL_ROOT_DIR=${OPENSSL_DIR} \
            -DOPENSSL_INCLUDE_DIR=${OPENSSL_DIR}/include \
            -DOPENSSL_CRYPTO_LIBRARY=${OPENSSL_DIR}/lib/libcrypto.a \
            -DOPENSSL_SSL_LIBRARY=${OPENSSL_DIR}/lib/libssl.a \
            -DOPENSSL_USE_STATIC_LIBS=TRUE \
            -DCURL_INCLUDE_DIR=${CURL_DIR}/include \
            -DCURL_LIBRARY="${CURL_DIR}/lib/libcurl.a;${CURL_DIR}/lib/libnghttp2.a;-lz"

          cmake --build . --parallel $(sysctl -n hw.ncpu)

      - name: Verify Build
        run: |
          echo "=== Verifying DuckDB build for ${{ matrix.target }} ==="
          find duckdb-src/build/${{ matrix.target }} -name "libduckdb.dylib" -o -name "libduckdb.so" 2>/dev/null | head -5
          DYLIB=$(find duckdb-src/build/${{ matrix.target }} -name "libduckdb.dylib" | head -1)
          if [ -n "$DYLIB" ]; then
            ls -la "$DYLIB"
            file "$DYLIB"
          fi

      - name: Create Framework
        run: |
          DUCKDB_VERSION="${{ needs.prepare.outputs.duckdb_version }}"
          DYLIB=$(find duckdb-src/build/${{ matrix.target }} -name "libduckdb.dylib" | head -1)

          if [ -z "$DYLIB" ]; then
            echo "ERROR: libduckdb.dylib not found"
            find duckdb-src/build/${{ matrix.target }} -type f -name "*.dylib" -o -name "*.so"
            exit 1
          fi

          # Create framework structure
          mkdir -p output/${{ matrix.target }}/duckdb.framework/Headers

          # Copy library and rename to framework binary name
          cp "$DYLIB" output/${{ matrix.target }}/duckdb.framework/duckdb

          # Copy header
          cp duckdb-src/src/include/duckdb.h output/${{ matrix.target }}/duckdb.framework/Headers/

          # Create Info.plist
          cat > output/${{ matrix.target }}/duckdb.framework/Info.plist << EOF
          <?xml version="1.0" encoding="UTF-8"?>
          <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
          <plist version="1.0">
          <dict>
            <key>CFBundleExecutable</key>
            <string>duckdb</string>
            <key>CFBundleIdentifier</key>
            <string>org.duckdb.duckdb</string>
            <key>CFBundleInfoDictionaryVersion</key>
            <string>6.0</string>
            <key>CFBundleName</key>
            <string>duckdb</string>
            <key>CFBundlePackageType</key>
            <string>FMWK</string>
            <key>CFBundleShortVersionString</key>
            <string>${DUCKDB_VERSION}</string>
            <key>CFBundleVersion</key>
            <string>${DUCKDB_VERSION}</string>
            <key>MinimumOSVersion</key>
            <string>${{ env.IOS_MIN_VERSION }}</string>
          </dict>
          </plist>
          EOF

          # Set install name
          install_name_tool -id "@rpath/duckdb.framework/duckdb" \
            output/${{ matrix.target }}/duckdb.framework/duckdb || true

          echo "=== Framework created ==="
          ls -la output/${{ matrix.target }}/duckdb.framework/

      - name: Upload Artifact
        uses: actions/upload-artifact@v4
        with:
          name: duckdb-${{ matrix.target }}
          path: output/${{ matrix.target }}/duckdb.framework
          retention-days: 1

  # ============================================================
  # Job 3: Create XCFramework and Release
  # ============================================================
  release:
    name: Create XCFramework & Release
    needs: [prepare, build]
    if: needs.prepare.outputs.should_build == 'true' && github.event.inputs.create_release != 'false'
    runs-on: macos-14
    steps:
      - name: Download All Artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: duckdb-*
          path: artifacts

      - name: Prepare Framework Structure
        run: |
          echo "=== Downloaded artifacts ==="
          find artifacts -type f | head -20

          # Artifacts are downloaded flat, need to restructure into .framework bundles
          for target in ios-arm64 ios-simulator-arm64 ios-simulator-x86_64; do
            echo "Restructuring $target..."
            mkdir -p "frameworks/${target}/duckdb.framework/Headers"
            cp "artifacts/duckdb-${target}/duckdb" "frameworks/${target}/duckdb.framework/duckdb"
            cp "artifacts/duckdb-${target}/Headers/"* "frameworks/${target}/duckdb.framework/Headers/" 2>/dev/null || true
            cp "artifacts/duckdb-${target}/Info.plist" "frameworks/${target}/duckdb.framework/" 2>/dev/null || true
          done

          echo "=== Restructured frameworks ==="
          find frameworks -type f | head -20

      - name: Create Fat Simulator Framework
        run: |
          # Create fat binary for simulator (arm64 + x86_64)
          mkdir -p fat-simulator/duckdb.framework/Headers

          lipo -create \
            frameworks/ios-simulator-arm64/duckdb.framework/duckdb \
            frameworks/ios-simulator-x86_64/duckdb.framework/duckdb \
            -output fat-simulator/duckdb.framework/duckdb

          # Copy headers and plist from one of the simulator builds
          cp frameworks/ios-simulator-arm64/duckdb.framework/Headers/* fat-simulator/duckdb.framework/Headers/
          cp frameworks/ios-simulator-arm64/duckdb.framework/Info.plist fat-simulator/duckdb.framework/

          # Set install name
          install_name_tool -id "@rpath/duckdb.framework/duckdb" fat-simulator/duckdb.framework/duckdb || true

          echo "=== Fat simulator framework ==="
          file fat-simulator/duckdb.framework/duckdb
          lipo -info fat-simulator/duckdb.framework/duckdb

      - name: Create XCFramework
        run: |
          # Create XCFramework combining device and simulator
          xcodebuild -create-xcframework \
            -framework frameworks/ios-arm64/duckdb.framework \
            -framework fat-simulator/duckdb.framework \
            -output duckdb.xcframework

          echo "=== XCFramework created ==="
          ls -la duckdb.xcframework/

      - name: Package Release Assets
        run: |
          mkdir -p release

          # Package XCFramework
          zip -r release/duckdb-xcframework-ios.zip duckdb.xcframework

          # Package regular framework (simulator for dev convenience)
          cd fat-simulator
          zip -r ../release/duckdb-framework-ios.zip duckdb.framework
          cd ..

          # Package device-only framework
          cd frameworks/ios-arm64
          zip -r ../../release/duckdb-framework-ios-device.zip duckdb.framework
          cd ../..

          echo "=== Release assets ==="
          ls -la release/

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ needs.prepare.outputs.release_tag }}
          name: "DuckDB ${{ needs.prepare.outputs.duckdb_version }} iOS Framework"
          body: |
            Pre-built DuckDB iOS framework for version ${{ needs.prepare.outputs.duckdb_version }}.

            ## Downloads
            - `duckdb-xcframework-ios.zip` - **Recommended** XCFramework with device and simulator
            - `duckdb-framework-ios.zip` - Framework with simulator support (for development)
            - `duckdb-framework-ios-device.zip` - Device-only framework (arm64)

            ## Build Configuration
            - **Architectures**: arm64 (device), arm64 + x86_64 (simulator)
            - **Minimum iOS**: ${{ env.IOS_MIN_VERSION }}

            ## Extensions (statically linked)
            Core: `${{ env.CORE_EXTENSIONS }}`
            Community: `${{ env.COMMUNITY_EXTENSIONS }}`

            ## Dependencies
            Built with libraries from [${{ env.OPENSSL_REPO }}](https://github.com/${{ env.OPENSSL_REPO }})

            Built automatically from [duckdb/duckdb v${{ needs.prepare.outputs.duckdb_version }}](https://github.com/duckdb/duckdb/releases/tag/v${{ needs.prepare.outputs.duckdb_version }})
          files: release/*.zip
          fail_on_unmatched_files: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Cleanup Artifacts
        uses: geekyeggo/delete-artifact@v5
        with:
          name: duckdb-*
